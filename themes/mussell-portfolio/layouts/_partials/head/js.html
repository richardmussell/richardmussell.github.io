{{- with resources.Get "js/main.js" }}
  {{- $opts := dict
    "minify" (not hugo.IsDevelopment)
    "sourceMap" (cond hugo.IsDevelopment "external" "")
    "targetPath" "js/main.js"
  }}
  {{- with . | js.Build $opts }}
    {{- if hugo.IsDevelopment }}
      <script src="{{ .RelPermalink }}"></script>
    {{- else }}
      {{- with . | fingerprint }}
        <script src="{{ .RelPermalink }}" integrity="{{ .Data.Integrity }}" crossorigin="anonymous"></script>
      {{- end }}
    {{- end }}
  {{- end }}
{{- end }}

<script>
  // Reading Progress Indicator
  (function() {
    const progressBar = document.createElement('div');
    progressBar.className = 'reading-progress';
    document.body.appendChild(progressBar);

    function updateProgress() {
      const windowHeight = window.innerHeight;
      const documentHeight = document.documentElement.scrollHeight;
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollableHeight = documentHeight - windowHeight;
      const progress = scrollableHeight > 0 ? (scrollTop / scrollableHeight) * 100 : 0;
      progressBar.style.width = Math.min(Math.max(progress, 0), 100) + '%';
    }

    // Throttle scroll events
    let ticking = false;
    window.addEventListener('scroll', function() {
      if (!ticking) {
        window.requestAnimationFrame(function() {
          updateProgress();
          ticking = false;
        });
        ticking = true;
      }
    }, { passive: true });

    updateProgress();
  })();

  // Header scroll behavior removed - header scrolls normally with page

  // Scroll to Top Button - Enterprise Ready with Accessibility
  (function() {
    const scrollToTopButton = document.getElementById('scroll-to-top');
    if (!scrollToTopButton) return;

    const scrollThreshold = 400; // Show button after scrolling 400px
    let ticking = false;

    function updateButtonVisibility() {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      
      if (scrollTop > scrollThreshold) {
        scrollToTopButton.classList.add('visible');
        scrollToTopButton.setAttribute('aria-hidden', 'false');
      } else {
        scrollToTopButton.classList.remove('visible');
        scrollToTopButton.setAttribute('aria-hidden', 'true');
      }
    }

    function scrollToTop() {
      // Smooth scroll to top
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
      
      // Focus management for accessibility
      scrollToTopButton.blur();
      
      // Announce to screen readers
      const announcement = document.createElement('div');
      announcement.setAttribute('role', 'status');
      announcement.setAttribute('aria-live', 'polite');
      announcement.setAttribute('aria-atomic', 'true');
      announcement.className = 'sr-only';
      announcement.textContent = 'Scrolled to top of page';
      document.body.appendChild(announcement);
      
      setTimeout(() => {
        document.body.removeChild(announcement);
      }, 1000);
    }

    // Handle scroll events
    window.addEventListener('scroll', function() {
      if (!ticking) {
        window.requestAnimationFrame(function() {
          updateButtonVisibility();
          ticking = false;
        });
        ticking = true;
      }
    }, { passive: true });

    // Handle button click
    scrollToTopButton.addEventListener('click', scrollToTop);

    // Handle keyboard navigation (Enter and Space)
    scrollToTopButton.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        scrollToTop();
      }
    });

    // Initial state
    updateButtonVisibility();
  })();

  // Screen reader only class for accessibility announcements
  if (!document.querySelector('style[data-sr-only]')) {
    const style = document.createElement('style');
    style.setAttribute('data-sr-only', 'true');
    style.textContent = `
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
      }
    `;
    document.head.appendChild(style);
  }
  
  // Mac Window Tab Switching
  (function() {
    const macTabs = document.querySelectorAll('.mac-tab');
    macTabs.forEach(tab => {
      tab.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const window = this.closest('.mac-window');
        const tabName = this.getAttribute('data-tab');
        
        // Update active tab
        window.querySelectorAll('.mac-tab').forEach(t => t.classList.remove('active'));
        this.classList.add('active');
        
        // Update active content
        window.querySelectorAll('.mac-tab-content').forEach(content => {
          content.classList.remove('active');
          if (content.getAttribute('data-content') === tabName) {
            content.classList.add('active');
          }
        });
      });
    });
  })();
  
  // Smooth Scroll for Domain Tabs
  (function() {
    const domainTabs = document.querySelectorAll('.domain-tab');
    domainTabs.forEach(tab => {
      tab.addEventListener('click', function(e) {
        const href = this.getAttribute('href');
        if (href && href.includes('#')) {
          e.preventDefault();
          const targetId = href.split('#')[1];
          const targetElement = document.getElementById(targetId);
          if (targetElement) {
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }
      });
    });
  })();
  
  // Staggered Mount Animation for Domain Sections
  (function() {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry, index) => {
        if (entry.isIntersecting) {
          setTimeout(() => {
            entry.target.style.opacity = '1';
            entry.target.style.transform = 'translateY(0)';
          }, index * 100);
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.1 });
    
    document.querySelectorAll('.domain-section').forEach(section => {
      section.style.opacity = '0';
      section.style.transform = 'translateY(20px)';
      section.style.transition = 'opacity 0.6s ease-out, transform 0.6s ease-out';
      observer.observe(section);
    });
  })();
  
  // Technical Registry Functionality
  (function() {
    // Search Functionality
    const searchInput = document.getElementById('service-search');
    if (searchInput) {
      let searchTimeout;
      searchInput.addEventListener('input', function(e) {
        clearTimeout(searchTimeout);
        const query = e.target.value.toLowerCase().trim();
        
        searchTimeout = setTimeout(() => {
          filterProjects(query, getActiveTags());
        }, 300);
      });
    }
    
    // Tag Filter Functionality
    const tagFilters = document.querySelectorAll('.tag-filter');
    tagFilters.forEach(filter => {
      filter.addEventListener('click', function() {
        const isChecked = this.getAttribute('aria-checked') === 'true';
        this.setAttribute('aria-checked', !isChecked);
        this.classList.toggle('active', !isChecked);
        
        const query = searchInput ? searchInput.value.toLowerCase().trim() : '';
        filterProjects(query, getActiveTags());
      });
    });
    
    function getActiveTags() {
      const activeTags = [];
      document.querySelectorAll('.tag-filter[aria-checked="true"]').forEach(filter => {
        activeTags.push(filter.getAttribute('data-tag'));
      });
      return activeTags;
    }
    
    function filterProjects(searchQuery, activeTags) {
      isFiltering = true;
      const projects = document.querySelectorAll('.system-spec');
      let visibleCount = 0;
      
      projects.forEach(project => {
        const projectId = project.getAttribute('data-project-id');
        const projectTags = project.getAttribute('data-tags').split(' ').filter(t => t);
        const projectText = project.textContent.toLowerCase();
        
        // Search filter
        const matchesSearch = !searchQuery || projectText.includes(searchQuery);
        
        // Tag filter
        const matchesTags = activeTags.length === 0 || 
          activeTags.some(tag => projectTags.includes(tag));
        
        if (matchesSearch && matchesTags) {
          project.classList.remove('hidden');
          visibleCount++;
        } else {
          project.classList.add('hidden');
        }
      });
      
      // Hide empty sections
      document.querySelectorAll('.registry-section').forEach(section => {
        const visibleProjects = section.querySelectorAll('.system-spec:not(.hidden)');
        if (visibleProjects.length === 0) {
          section.style.display = 'none';
        } else {
          section.style.display = 'block';
        }
      });
      
      // Update results count
      const countElement = document.querySelector('.sidebar-count');
      if (countElement) {
        countElement.textContent = `${visibleCount} Services`;
      }
      
      // Re-observe sections after filtering (in case layout changed)
      requestAnimationFrame(() => {
        document.querySelectorAll('.registry-section').forEach(section => {
          observer.observe(section);
        });
        isFiltering = false;
      });
    }
    
    // Tab Switching with Lazy Loading
    document.querySelectorAll('.viewport-tab').forEach(tab => {
      tab.addEventListener('click', function(e) {
        e.preventDefault();
        const projectId = this.getAttribute('data-project-id');
        const tabName = this.getAttribute('data-tab');
        const viewport = this.closest('.media-viewport');
        
        // Update active tab
        viewport.querySelectorAll('.viewport-tab').forEach(t => {
          t.classList.remove('active');
          t.setAttribute('aria-selected', 'false');
          t.setAttribute('aria-expanded', 'false');
        });
        this.classList.add('active');
        this.setAttribute('aria-selected', 'true');
        this.setAttribute('aria-expanded', 'true');
        
        // Update active pane
        viewport.querySelectorAll('.viewport-pane').forEach(pane => {
          pane.classList.remove('active');
        });
        const targetPane = viewport.querySelector(`#${tabName}-${projectId}`);
        if (targetPane) {
          targetPane.classList.add('active');
          
          // Lazy load content when tab becomes active
          if (tabName === 'loom') {
            const iframe = targetPane.querySelector('.loom-iframe.lazy-iframe');
            const poster = targetPane.querySelector('.loom-poster');
            if (iframe && !iframe.src) {
              const src = iframe.getAttribute('data-src');
              if (src) {
                iframe.src = src;
                iframe.classList.add('loaded');
                iframe.style.display = 'block';
                if (poster) {
                  poster.style.display = 'none';
                }
              }
            }
          } else if (tabName === 'diagram') {
            const facade = targetPane.querySelector('.diagram-facade');
            const lazyImage = targetPane.querySelector('.lazy-diagram');
            if (facade && lazyImage && !lazyImage.classList.contains('loaded')) {
              const diagramUrl = facade.getAttribute('data-diagram-url');
              if (diagramUrl) {
                lazyImage.src = diagramUrl;
                lazyImage.classList.add('loaded');
                facade.classList.add('loaded');
                lazyImage.style.display = 'block';
              }
            }
          }
        }
      });
    });
    
    // Registry Navigation - Enterprise Command Center
    let isScrolling = false;
    let isFiltering = false;
    
    // Intersection Observer for automatic active state tracking
    const observerOptions = {
      root: null,
      rootMargin: '-120px 0px -50% 0px', // Account for sticky navbar
      threshold: 0
    };
    
    const observer = new IntersectionObserver((entries) => {
      if (isScrolling || isFiltering) return; // Don't update during programmatic actions
      
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const section = entry.target;
          const sectionId = section.getAttribute('id');
          
          // Update active state in sidebar
          document.querySelectorAll('.toc-link').forEach(link => {
            const href = link.getAttribute('href');
            if (href && href === `#${sectionId}`) {
              link.classList.add('active');
            } else {
              link.classList.remove('active');
            }
          });
        }
      });
    }, observerOptions);
    
    // Observe all registry sections
    document.querySelectorAll('.registry-section').forEach(section => {
      observer.observe(section);
    });
    
    // Single-click navigation handler
    document.querySelectorAll('.toc-link').forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const href = this.getAttribute('href');
        const sectionId = this.getAttribute('data-section-id');
        
        if (!href || !href.startsWith('#')) return;
        
        const targetId = href.substring(1);
        const targetSection = document.getElementById(targetId);
        const targetHeading = document.getElementById(`heading-${targetId}`);
        
        if (!targetSection) return;
        
        // Update active state immediately for visual feedback
        document.querySelectorAll('.toc-link').forEach(l => l.classList.remove('active'));
        this.classList.add('active');
        
        isScrolling = true;
        
        // Wait for any DOM updates (filtering, layout shifts) to complete
        requestAnimationFrame(() => {
          // Re-calculate position after potential layout shifts
          const targetElement = targetHeading || targetSection;
          
          // Calculate the exact scroll position accounting for sticky navbar
          const headerOffset = 100; // Sticky navbar height (80px) + breathing room (20px)
          const elementPosition = targetElement.getBoundingClientRect().top;
          const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
          
          // Smooth scroll to the calculated position
          window.scrollTo({
            top: Math.max(0, offsetPosition),
            behavior: 'smooth'
          });
          
          // Mark scrolling as complete after animation
          setTimeout(() => {
            isScrolling = false;
          }, 600); // Wait for scroll animation to complete
          
          // Update focus for accessibility
          targetElement.setAttribute('tabindex', '-1');
          targetElement.focus();
        });
      });
    });
    
    // Update active state on initial load
    const firstSection = document.querySelector('.registry-section');
    if (firstSection) {
      const firstSectionId = firstSection.getAttribute('id');
      document.querySelectorAll('.toc-link').forEach(link => {
        const href = link.getAttribute('href');
        if (href && href === `#${firstSectionId}`) {
          link.classList.add('active');
        }
      });
    }
    
    // Modal Functionality
    const modal = document.getElementById('manifest-modal');
    const manifestButtons = document.querySelectorAll('.manifest-button');
    const modalClose = document.querySelector('.modal-close');
    const modalOverlay = document.querySelector('.modal-overlay');
    
    // Mock manifest data (in production, this would come from the project data)
    const manifestTemplates = {
      default: `apiVersion: v1
kind: Deployment
metadata:
  name: {{ "{{" }}PROJECT_NAME{{ "}}" }}
  labels:
    app: {{ "{{" }}PROJECT_NAME{{ "}}" }}
    version: v1.0.0
spec:
  replicas: 3
  selector:
    matchLabels:
      app: {{ "{{" }}PROJECT_NAME{{ "}}" }}
  template:
    metadata:
      labels:
        app: {{ "{{" }}PROJECT_NAME{{ "}}" }}
    spec:
      containers:
      - name: {{ "{{" }}PROJECT_NAME{{ "}}" }}
        image: {{ "{{" }}IMAGE{{ "}}" }}
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"`
    };
    
    manifestButtons.forEach(button => {
      button.addEventListener('click', function() {
        const projectId = this.getAttribute('data-project-id');
        const project = document.querySelector(`[data-project-id="${projectId}"]`);
        const projectTitle = project ? project.querySelector('.spec-title').textContent : 'Project';
        
        const manifestContent = document.getElementById('manifest-content');
        if (manifestContent) {
          manifestContent.textContent = manifestTemplates.default
            .replace(/\{\{PROJECT_NAME\}\}/g, projectTitle.toLowerCase().replace(/\s+/g, '-'))
            .replace(/\{\{IMAGE\}\}/g, `registry.example.com/${projectTitle.toLowerCase().replace(/\s+/g, '-')}:latest`);
        }
        
        modal.setAttribute('aria-hidden', 'false');
        document.body.style.overflow = 'hidden';
        
        // Focus management
        const closeButton = modal.querySelector('.modal-close');
        if (closeButton) {
          closeButton.focus();
        }
      });
    });
    
    function closeModal() {
      modal.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
      
      // Return focus to the button that opened the modal
      const activeButton = document.activeElement;
      if (activeButton && activeButton.classList.contains('manifest-button')) {
        activeButton.focus();
      }
    }
    
    if (modalClose) {
      modalClose.addEventListener('click', closeModal);
    }
    
    if (modalOverlay) {
      modalOverlay.addEventListener('click', closeModal);
    }
    
    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && modal.getAttribute('aria-hidden') === 'false') {
        closeModal();
      }
    });
    
    // Trap focus within modal
    if (modal) {
      const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];
      
      modal.addEventListener('keydown', function(e) {
        if (e.key !== 'Tab' || modal.getAttribute('aria-hidden') === 'true') return;
        
        if (e.shiftKey) {
          if (document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
          }
        } else {
          if (document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
          }
        }
      });
    }
  })();
  
  // Command Palette (Cmd+K / Ctrl+K)
  (function() {
    const palette = document.getElementById('command-palette');
    const paletteSearch = document.getElementById('palette-search');
    const paletteResults = document.getElementById('palette-results');
    const paletteClose = document.querySelector('.palette-close');
    const paletteOverlay = document.querySelector('.palette-overlay');
    
    if (!palette || !paletteSearch) return;
    
    // Collect all projects for search
    const projects = Array.from(document.querySelectorAll('.system-spec')).map(spec => {
      const title = spec.querySelector('.spec-title')?.textContent || '';
      const category = spec.closest('.registry-section')?.querySelector('.section-heading')?.textContent || '';
      const tags = spec.getAttribute('data-tags')?.split(' ').filter(t => t) || [];
      const link = spec.querySelector('.spec-link')?.getAttribute('href') || '';
      return { title, category, tags, link, element: spec };
    });
    
    function openPalette() {
      palette.setAttribute('aria-hidden', 'false');
      document.body.style.overflow = 'hidden';
      paletteSearch.focus();
      updatePaletteResults('');
    }
    
    function closePalette() {
      palette.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
    }
    
    function updatePaletteResults(query) {
      const queryLower = query.toLowerCase().trim();
      paletteResults.innerHTML = '';
      
      if (!queryLower) {
        // Show all projects
        projects.forEach((project, index) => {
          const item = createPaletteItem(project, index);
          paletteResults.appendChild(item);
        });
        return;
      }
      
      // Filter projects
      const filtered = projects.filter(project => {
        const matchesTitle = project.title.toLowerCase().includes(queryLower);
        const matchesCategory = project.category.toLowerCase().includes(queryLower);
        const matchesTags = project.tags.some(tag => tag.includes(queryLower));
        return matchesTitle || matchesCategory || matchesTags;
      });
      
      filtered.forEach((project, index) => {
        const item = createPaletteItem(project, index);
        paletteResults.appendChild(item);
      });
      
      if (filtered.length === 0) {
        const noResults = document.createElement('div');
        noResults.className = 'palette-result-item';
        noResults.textContent = 'No results found';
        noResults.style.color = 'var(--text-secondary)';
        noResults.style.cursor = 'default';
        paletteResults.appendChild(noResults);
      }
    }
    
    function createPaletteItem(project, index) {
      const item = document.createElement('div');
      item.className = 'palette-result-item';
      item.setAttribute('role', 'option');
      item.setAttribute('tabindex', '0');
      item.setAttribute('aria-selected', 'false');
      item.setAttribute('data-index', index);
      
      item.innerHTML = `
        <div>
          <div class="palette-result-title">${project.title}</div>
          <div class="palette-result-meta">${project.category}</div>
        </div>
      `;
      
      item.addEventListener('click', () => {
        project.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        project.element.setAttribute('tabindex', '-1');
        project.element.focus();
        closePalette();
      });
      
      item.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          item.click();
        }
      });
      
      return item;
    }
    
    // Keyboard shortcut
    document.addEventListener('keydown', (e) => {
      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
      const isCmdK = (isMac && e.metaKey && e.key === 'k') || (!isMac && e.ctrlKey && e.key === 'k');
      
      if (isCmdK) {
        e.preventDefault();
        if (palette.getAttribute('aria-hidden') === 'true') {
          openPalette();
        } else {
          closePalette();
        }
      }
      
      // Close on Escape
      if (e.key === 'Escape' && palette.getAttribute('aria-hidden') === 'false') {
        closePalette();
      }
    });
    
    // Search input
    paletteSearch.addEventListener('input', (e) => {
      updatePaletteResults(e.target.value);
    });
    
    // Close buttons
    if (paletteClose) {
      paletteClose.addEventListener('click', closePalette);
    }
    
    if (paletteOverlay) {
      paletteOverlay.addEventListener('click', closePalette);
    }
    
    // Arrow key navigation in results
    paletteSearch.addEventListener('keydown', (e) => {
      const items = Array.from(paletteResults.querySelectorAll('.palette-result-item'));
      const currentIndex = items.findIndex(item => item.getAttribute('aria-selected') === 'true');
      
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        const nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
        items.forEach((item, i) => {
          item.setAttribute('aria-selected', i === nextIndex ? 'true' : 'false');
        });
        items[nextIndex].focus();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        const prevIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
        items.forEach((item, i) => {
          item.setAttribute('aria-selected', i === prevIndex ? 'true' : 'false');
        });
        items[prevIndex].focus();
      }
    });
  })();
  
  // Lazy Load Diagrams (Media Facade Pattern)
  (function() {
    // Load diagram when Diagram tab is clicked
    document.querySelectorAll('.viewport-tab[data-tab="diagram"]').forEach(tab => {
      tab.addEventListener('click', function() {
        const projectId = this.getAttribute('data-project-id');
        const pane = document.getElementById(this.getAttribute('aria-controls'));
        const facade = pane?.querySelector('.diagram-facade');
        const lazyImage = pane?.querySelector('.lazy-diagram');
        
        if (facade && lazyImage && !lazyImage.classList.contains('loaded')) {
          const diagramUrl = facade.getAttribute('data-diagram-url');
          if (diagramUrl) {
            lazyImage.src = diagramUrl;
            lazyImage.classList.add('loaded');
            facade.classList.add('loaded');
            lazyImage.style.display = 'block';
          }
        }
        
        // Load Mermaid diagram if present
        const mermaidContainer = pane?.querySelector('.mermaid');
        if (mermaidContainer && !mermaidContainer.classList.contains('rendered')) {
          const mermaidCode = mermaidContainer.getAttribute('data-mermaid') || mermaidContainer.textContent;
          if (mermaidCode && typeof mermaid !== 'undefined') {
            mermaidContainer.classList.add('rendered');
            // Mermaid will auto-render on next tick
          }
        }
      });
    });
    
    // Load diagram when Load button is clicked
    document.querySelectorAll('.diagram-load-button').forEach(button => {
      button.addEventListener('click', function() {
        const facade = this.closest('.diagram-facade');
        const container = facade?.closest('.diagram-container');
        const lazyImage = container?.querySelector('.lazy-diagram');
        
        if (facade && lazyImage) {
          const diagramUrl = facade.getAttribute('data-diagram-url');
          if (diagramUrl) {
            lazyImage.src = diagramUrl;
            lazyImage.classList.add('loaded');
            facade.classList.add('loaded');
            lazyImage.style.display = 'block';
          }
        }
      });
    });
  })();
  
  // Lazy Load Loom Iframes (Media Facade Pattern)
  (function() {
    document.querySelectorAll('.loom-play-button').forEach(playButton => {
      playButton.addEventListener('click', function() {
        const poster = this.closest('.loom-poster');
        const container = poster?.closest('.loom-container');
        const iframe = container?.querySelector('.loom-iframe.lazy-iframe');
        
        if (iframe && !iframe.src) {
          const src = iframe.getAttribute('data-src');
          if (src) {
            iframe.src = src;
            iframe.classList.add('loaded');
            iframe.style.display = 'block';
            if (poster) {
              poster.style.display = 'none';
            }
          }
        }
      });
    });
  })();
  
  // Mac Terminal Header for Code Blocks
  (function() {
    document.querySelectorAll('.project-content pre').forEach(pre => {
      // Check if already wrapped
      if (pre.querySelector('.mac-terminal-header')) return;
      
      const code = pre.querySelector('code');
      if (!code) return;
      
      // Create terminal header
      const header = document.createElement('div');
      header.className = 'mac-terminal-header';
      header.innerHTML = `
        <div class="mac-terminal-dot"></div>
        <div class="mac-terminal-dot"></div>
        <div class="mac-terminal-dot"></div>
      `;
      
      // Wrap code in container
      const codeContainer = document.createElement('div');
      codeContainer.className = 'mac-terminal-code';
      codeContainer.appendChild(code.cloneNode(true));
      
      // Clear pre and add header + code
      pre.innerHTML = '';
      pre.appendChild(header);
      pre.appendChild(codeContainer);
    });
  })();
  
  // Copy Code to Clipboard
  (function() {
    document.querySelectorAll('.copy-code-button').forEach(button => {
      button.addEventListener('click', async function() {
        const codeContainer = this.closest('.code-container');
        const codeBlock = codeContainer?.querySelector('code');
        if (!codeBlock) return;
        
        // Get text content, handling Prism.js highlighting
        const code = codeBlock.textContent || codeBlock.innerText;
        
        try {
          await navigator.clipboard.writeText(code);
          this.classList.add('copied');
          
          setTimeout(() => {
            this.classList.remove('copied');
          }, 2000);
        } catch (err) {
          console.error('Failed to copy code:', err);
        }
      });
    });
  })();
  
  // Update aria-expanded on tab switchers
  (function() {
    document.querySelectorAll('.viewport-tab').forEach(tab => {
      tab.addEventListener('click', function() {
        const viewport = this.closest('.media-viewport');
        const allTabs = viewport.querySelectorAll('.viewport-tab');
        allTabs.forEach(t => {
          t.setAttribute('aria-expanded', t === this ? 'true' : 'false');
        });
      });
    });
  })();
  
  // Global Deployment Map - Node Hover Popup
  (function() {
    const nodes = document.querySelectorAll('.deployment-node');
    const popup = document.getElementById('system-pulse-popup');
    const mapWrapper = document.querySelector('.deployment-map-wrapper');
    
    if (!nodes.length || !popup || !mapWrapper) return;
    
    nodes.forEach(node => {
      const nodeCircle = node.querySelector('.node-pulse');
      
      node.addEventListener('mouseenter', function(e) {
        const rect = nodeCircle.getBoundingClientRect();
        const mapRect = mapWrapper.getBoundingClientRect();
        
        // Position popup above the node
        const popupX = rect.left + (rect.width / 2) - (popup.offsetWidth / 2);
        const popupY = rect.top - popup.offsetHeight - 12;
        
        // Ensure popup stays within map bounds
        const finalX = Math.max(10, Math.min(popupX, window.innerWidth - popup.offsetWidth - 10));
        const finalY = Math.max(10, popupY);
        
        popup.style.left = `${finalX}px`;
        popup.style.top = `${finalY}px`;
        popup.classList.add('visible');
        popup.setAttribute('aria-hidden', 'false');
      });
      
      node.addEventListener('mouseleave', function() {
        popup.classList.remove('visible');
        popup.setAttribute('aria-hidden', 'true');
      });
      
      // Handle touch events for mobile
      node.addEventListener('touchstart', function(e) {
        e.preventDefault();
        const rect = nodeCircle.getBoundingClientRect();
        const popupX = rect.left + (rect.width / 2) - (popup.offsetWidth / 2);
        const popupY = rect.top - popup.offsetHeight - 12;
        
        const finalX = Math.max(10, Math.min(popupX, window.innerWidth - popup.offsetWidth - 10));
        const finalY = Math.max(10, popupY);
        
        popup.style.left = `${finalX}px`;
        popup.style.top = `${finalY}px`;
        popup.classList.add('visible');
        popup.setAttribute('aria-hidden', 'false');
      });
    });
    
    // Close popup when clicking outside
    document.addEventListener('click', function(e) {
      if (!mapWrapper.contains(e.target) && !popup.contains(e.target)) {
        popup.classList.remove('visible');
        popup.setAttribute('aria-hidden', 'true');
      }
    });
  })();
</script>
